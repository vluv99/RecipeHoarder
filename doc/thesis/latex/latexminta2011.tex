% LaTeX mintafájl szakdolgozat és diplomamunkáknak az
% SZTE Informatikai Tanszekcsoportja által megkövetelt
% formai követelményeinek megvalósításához
% Modositva: 2011.04.28 Nemeth L. Zoltan
% A fájl használatához szükséges a magyar.ldf 2005/05/12 v1.5-ös vagy későbbi verziója
% ez letölthető a http://www.math.bme.hu/latex/ weblapról, a magyar nyelvű szedéshez
% Hasznos információk, linekek, LaTeX leirasok a www.latex.lap.hu weboldalon vannak.
%


\documentclass[12pt]{report}



%Az ékezetes betűk használatához:
\usepackage[T1]{fontenc}% ékezetes szavak automatikus elválasztásához
\usepackage[utf8]{inputenc}% ékezetes szavak beviteléhez

%Magyar nyelvi támogatás (Babel 3.7 vagy későbbi kell!)
%\def\magyarOptions{defaults=hu-min}
\usepackage[magyar]{babel}


% Margók és lap geometria beállítása
\usepackage{geometry}
\geometry{
  a4paper,
  %total={170mm,257mm},
  %left=2.5cm,
  top=2.5cm,
  %right=2.5cm,
  bottom=2.5cm
}

% A formai kovetelmenyekben megkövetelt Times betűtípus hasznalata:
\usepackage{times}

%Az AMS csomagjai
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

%A fejléc láblécek kialakításához:
\usepackage{fancyhdr}

%Természetesen további csomagok is használhatók,
%például ábrák beillesztéséhez a graphix és a psfrag,
%ha nincs rájuk szükség természetesen kihagyhatók.
\usepackage{graphicx}
\usepackage{psfrag}
\usepackage{xcolor}
\usepackage[hidelinks]{hyperref}

\usepackage{booktabs}
\usepackage{pifont}
\usepackage{float}
%\usepackage{subcaption}
\usepackage{subfig}
\usepackage{glossaries}

%Tételszerű környezetek definiálhatók, ezek most fejezetenkent egyutt szamozodnak, pl.
\newtheorem{tet}{Tétel}[chapter]
\newtheorem{defi}[tet]{Definíció}
\newtheorem{lemma}[tet]{Lemma}
\newtheorem{áll}[tet]{Állítás}
\newtheorem{köv}[tet]{Következmény}

%Ha a megjegyzések és a példak szövegét nem akarjuk dőlten szedni, akkor
%az alábbi parancs után kell őket definiální:
\theoremstyle{definition}
\newtheorem{megj}[tet]{Megjegyzés}
\newtheorem{pld}[tet]{Példa}

%Margók:
\hoffset -1in
%\voffset 9.6mm%-1in % -25.4,,
%\oddsidemargin 35mm
%\textwidth 150mm
%\topmargin 15mm
%\headheight 10mm
%\headsep 5mm
%\textheight 237mm

\oddsidemargin 35mm%= 1cm

\makeglossaries

\input{glossary.tex}



\begin{document}

%A FEJEZETEK KEZDŐOLDALAINAK FEJ ES LÁBLÉCE:
%a plain oldalstílust kell átdefiniálni, hogy ott ne legyen fejléc:
\fancypagestyle{plain}{%
	%ez mindent töröl:
	\fancyhf{}
	% a láblécbe jobboldalra kerüljön az oldalszám:
	\fancyfoot[R]{\thepage}
	%elválasztó vonal sem kell:
	\renewcommand{\headrulewidth}{0pt}
}

%A TÖBBI OLDAL FEJ ÉS LÁBLÉCE:
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Recipe hoarder webes alkalmazás}
\fancyfoot[R]{\thepage}


%A címoldalra se fej- se lábléc nem kell:
\thispagestyle{empty}

\begin{center}
	\vspace*{1cm}
	{\Large\bf Szegedi Tudományegyetem}

	\vspace{0.5cm}

	{\Large\bf Informatikai Intézet}

	\vspace*{3.8cm}


	{\LARGE\bf Recipe hoarder webes alkalmazás}
	\\\vspace*{0.3cm}
	{\Large\bf (Recipe hoarder web application)}


	\vspace*{3.6cm}

	{\Large Szakdolgozat}
	% vagy {\Large Szakdolgozat}

	\vspace*{4cm}

	%Értelemszerűen megváltoztatandó:
	{\large
		\begin{tabular}{c@{\hspace{4cm}}c}
			\emph{Készítette:}         & \emph{Témavezető:}      \\
			\bf{Vas Laura}             & \bf{Dr. Bilicki Vilmos} \\
			gazdaságinformatika szakos & egyetemi adjunktus      \\
			hallgató                   &
		\end{tabular}
	}

	\vspace*{2.3cm}

	{\Large
		Szeged
		\\
		\vspace{2mm}
		2021
	}
\end{center}


%A tartalomjegyzék:
\tableofcontents

%A \chapter* parancs nem ad a fejezetnek sorszámot
\chapter*{Feladatkiírás}
%A tartalomjegyzékben mégis szerepeltetni kell, mint szakasz(section) szerepeljen:
\addcontentsline{toc}{section}{Feladatkiírás}

A szakdolgozat során egy Angular keretrendszerben kialakított webes alkalmazás létrehozása volt a feladatom. A projekt a Firebase felhőalapú szolgáltatásait használja. A fejlesztés során a legfőbb cél a más honlapokról való recept importálás megvalósítása volt. Az importálás egyik legfontosabb lépése az alapanyagok szétválogatása, hogy később a bevásárlólistába helyezésnél a megegyező anyagokat össze lehessen adni.   

\chapter*{Tartalmi összefoglaló}
\addcontentsline{toc}{section}{Tartalmi összefoglaló}

\begin{itemize}
	\item Téma  megnevezése: \\
	A szakdolgozat céljául kitűzött témám egy Angular-ban írt web applikáció, ami étel receptek megjelenítésre és importálásra használható. Innentől kezdve a recept mindig étel receptet jelent.
	\item Feladat  megfogalmazása: \\
	Az importálás funkció lehetővé teszi, hogy a felhasználók egy helyen gyűjtsék a receptjeiket. Ezen túl az is, hogy a receptek összetevőit egy bevásárló listába ki tudják menteni, ezzel is megkönnyítve a mindennapi életet. A felhasználók a többiek által létrehozott receptek között tudnak keresni, és a nekik tetsző recepteket ki tudják menteni a saját receptgyűjteményeikbe.
	\item Megoldási  mód: \\
	Az applikáció egy weblap formájában lett megvalósítva, mivel így lehet a legtöbb eszközt elérni egyetlen kód bázissal. A megvalósításhoz a már említett Angular keretrendszert használtam, illetve a Firebase felhő alapú szolgáltatásait. Mivel mind a kettő (Angular, Firebase) a Google terméke, ezért várhatóan hosszútávon támogatva lesznek. A felhasználó a recept URL-je alapján tud receptet importálni, vagy manuálisan is lehet létrehozni újat. Ekkor az importáláshoz egy szerver oldali funkció fut le és próbálja értelmezni a megkapott URL-en lévő html fájlt. Ennek egy fontos lépése az, hogy az alapanyagok nevét, mértékegységét és mennyiségét az eredeti helyről kiolvassa. Miután a receptet sikeresen importáltuk, azokat a Firebase adatbázisában tároljuk. 
	\item Alkalmazott  eszközök, módszerek: \\
	Mind az importálás, mind az egész projekt során törekedtem arra, hogy minél modulárisabb legyen a felépítés. A webapp fejlesztése során a PWA-t alkalmazva elérhető, hogy bizonyos funkciók offline is működjenek. Ezt a modern, könnyen kezelhető weblapot számítógépen és telefonon egyaránt lehet használni.
	\item Elért  eredmény: \\
	A fejlesztés során sikerült egy modern telefonos és számítógépes környezetben is elérhető webes alkalmazást készíteni, ami bárki számára a regisztráció után elérhető és könnyen használható, ezzel egyszerűbbé téve a hétköznapokat.
	\item Kulcsszavak: \\
	Angular, Firebase, pipeline architektúra, PWA, telefonos nézet
\end{itemize}

%Bevezetés
\chapter*{Motiváció}
\addcontentsline{toc}{section}{Motiváció}
Egyetemisták, mint én is, egyre közelebb vagyunk ahhoz az életformához, ahol önellátók vagyunk, ennek fontos része a főzés és étkezés. Manapság nagyon egyszerű különböző recepteket különböző országokból, kultúrákból találni, viszont ez temérdek weblapot jelenthet. Ennek hátulütője, hogy egy idő után követhetetlen lesz, hogy egyáltalán hova regisztráltunk, valamint, hogy “melyik weblapon is volt az a bizonyos recept, amit egyszer már kipróbáltam, és tetszett”. Személyes tapasztalatom ezzel kapcsolatban pedig, hogy egy chat alkalmazásban gyűjtöttük a barátommal az URL címeket, hogy legközelebb is megtaláljuk, de már kezdett nagyon követhetetlen lenni.

Azért választottam ezt az ötletet a szakdolgozatom témájának, mert ez egy személyes problémám már hosszú ideje. Láttam már korábban próbálkozásokat, de egyik sem volt az én elképzelésemnek megfelelő. A célom az volt, hogy egy egyszerű URL cím másolással pillanatok alatt egy helyen lehessen megtalálni mindent. 

A továbbiakban részletesen kifejtem az általam tervezett és megvalósított webes applikáció felépítését és funkcióit. A bemutatót a konkurencia ismertetésével kezdem.



\chapter{Piackutatás}
Sok hasonló jellegű weboldal létezik, mindnek kölünböző funkcióik, felhasználó körük, előnyeik és hátrányaik vannak. A jelen dolgozat projektje igyekszik a többi weblap hiányosságait elkerülni, ezzel szélesebb felhasználói kört magához vonzani.


\section{Grocy}
A Grocy egy lokálisan hosztolható weblap, ez azt jelenti, hogy minden felhasználónak rendelkeznie kell egy szerver géppel, amin magát a weblapot tudja üzemeltetni. Maga a weblap kifejezetten sok funkcióval rendelkezik, de ezeknek a teljes kihasználásához sok időt és munkát kell befektetni. Sajnos, mivel mindenki saját magának futtatja, ezért a beépített adatbázisa üresen kezd. A befektetett munka akkor tud kifizetődő lenni, ha valaki hosszú ideig használja.

A recept kezelő része csak manuálisan feltölthető, tehát nincs importálásra lehetőség. Rendelkezik bevásárlólista és “sufni” opciókkal is. Az otthon lévő alapanyagokat egyesével, tetszőleges részletességgel fel lehet venni a “sufniba”, ezzel leltározva, hogy milyen alapanyagok vannak otthon. Ezekről eltárolható adat az, hogy mennyi van belőle, meddig jók, képet, de akár a vonalkódját is. A bevásárló lista pedig egyértelműen a vásárlást segítő funkció, aminek a végén egy kattintásra átrakható “sufniba”.

Már ezen leírás alapján is látszik, hogy ahhoz, hogy ez a rendszer használható legyen, egy komoly lokális adatbázist kell létrehozni az alapanyagokból és azok adatairól, valamint a receptekről. Ez a rendszer csak olyan emberek számára használható, akik rendelkeznek hardverrel és tudással, hogy maguknak futtassák a weblapot.
 

\section{Delish}
Ez a weblap azért szerepel, mert ez egy tökéletes példa egy átlagos, egyszerű receptes weblapra.  A honlapon csak receptek és pár blog bejegyzés található regisztráció után is. Ez a weblap reprezentálja a legtöbb hasonló, csak blogként működő weboldalt.

Egy receptre kattintva láthatóak a hozzávalók, elkészítési javaslat, valamint az alapadatok, mint például az elkészítési idő. A weblapon találhatóak még hasonló recept ajánlások, de ezen felül több szolgáltatást nem nyújt.


\section{Yummly}
Ez egy fejlettebb verziója a korábban említett "átlagos" weblapoknak. Bejelentkezés nélkül kevesebb funkció érhető el, viszont utána már kifejezetten sok funkcionalitása van. A webes kinézeten felül applikációval is rendelkezik. 

Az alap recept keresésen kívül itt már lehetőségünk van azok elmentésére a sajátjaink közé. A weblap rendelkezik bevásárló lista funkcióval, valamint képes azonnal a receptből áthelyezni az alapanyagokat is. Egy kiemelkedő funkciója az étkezés tervező. Ez figyelembe vesz esetleges allergiákat, vagy étrendeket ajánl és segít tervezni a következő időszakra. 

Ami hátrány az egész weblapon, hogy nem közösség bővíti a recept adatbázist, ezért limitált a receptek száma és nem lehet mindent megtalálni. Mivel nincs importálási lehetőség, nem a legegyszerűbb használni, mert kézzel kell beírni az adatokat.


\section{BigOven}
A legnagyobb különbség az eddigiekhez képest, hogy ez a weblap már rendelkezik recept importáló funkcióval is. Azon felül négy különböző módon lehet újakat létrehozni: manuálisan leírva; másolni egy már létező fájlból és beilleszteni; képről vagy scennelésről beolvasni; URL címmel importálni. Az importálás során nem tárolják el az egész receptet, ha más honlapról származik. Az "Our Pledge to Food Bloggers" leírja, hogy ez miért van így, viszont ez azt jelenti, hogy a teljes recept megtekintéséhez át kell navigálni az eredeti oldalra. Ezen túl a bevásárló listában nem adódnak össze az azonos nevű termékek, valamint nincsenek kategóriák a receptekhez.

Egy nagy hátránya a weblapnak, hogy kissé régi stílusú. Az oldal nem használ túl sok modern stílust. A képek, beviteli mezők, lista nézetek mind úgy néznek ki, mint amin épp hogy van egy kis formázás. A weboldal navigációja nem túl  felhasználóbarát. 

Annak ellenére, hogy a weblapnak mennyire nem modern stílusa van, az applikáció igenis követhető. A funkciók szintén jól működnek. Egy nagy előny, hogy az ingyenes verzióban is használhatóak az alapfunkciók. 


\section{ChefTap}
Az összes közül valószínűleg ez az applikáció, ami a legtöbb funkcióval rendelkezik. Technikailag van webes és telefonos verziója is, viszont a webes csak recept megtekintésre használható. Minden egyebet, beleértve a recept importálást, bevásárló listákat és étkezés tervezőt, csak az applikáción keresztül lehet elérni és szerkeszteni. A weben van lehetőség Google segítségével bejelentkezni, viszont az applikációnak nincs ilyen lehetősége. Ennél az appnál az ingyenes verzió elég limitált, a recept importáláson kívül semmi sem működik a próbaidőszak lejárta után.

Ezen a felületen nincs lehetőség egy közös adatbázisból való keresésre.  A felhasználónak mindent magának kell beszerezni. 

Az importált recepteket könnyű módosítani, valamint rengeteg kis adatot megadni, hogy otthonosan lehessen használni a környezetet. Ám az applikációban nincs lehetőség közvetlenül a receptből a bevásárló listába rakni alapanyagokat, menüket összekészíteni vagy az étkezéstervezőt használni az ingyenes próbaverzió után.


\section{Összefoglaló}
A piackutatás során egyértelműen kiderült, melyek a legnépszerűbb funkciók, amiket minden program megvalósít. Érdekes eredmény például, hogy az emberek számára nem fontos, hogy maguknak tudják hosztolni a programot, hanem még akár fizetni is hajlandóak érte. Így amennyiben szükséges, a mi szoftverünket is lehet előfizetéshez kötni.

További megfigyelés, hogy a legtöbb weboldal nem támogatja a teljes körű recept importálást más forrásokból. Ennek lehet fejlesztési és jogi indoklása is, de biztos, hogy a felhasználók számára ez egy hasznos funkció lenne. Így biztosan megéri a projekt részeként megvalósítani. Érdekesség, hogy a BigOven tud kép alapján betölteni egy receptet, ez nagy segítséget jelent azon felhasználóknak, akiknek sok régi receptkönyvük van. Ehhez képfelismerési algoritmusokra van szükség, amik komplexitása igen nagy, igy a feljesztésük drága, ez jól magyarázza, miért csak egyetlen weblap támogatja a listából.

A piackutatás összes eredményét \az{\ref{fig:table}} ábra foglalja össze. 


\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

\noindent
\begin{figure}[H]
	\centering

	\begin{tabular}{p{3cm} | c c c c c | c | @{}}
		\multicolumn{7}{c}{Összegzés}                                                                   \\ \midrule
		weblapok                         & Grocy  & Delish & Yummly & BigOven & ChefTap & RecipeHoarder \\ \cmidrule[2pt](r){2-7}
		open source                      & \cmark & \xmark & \xmark & \xmark  & \xmark  & \xmark \footnotemark\\\cmidrule(r){2-7}
		fizetős                          & \xmark & \xmark & \xmark & \cmark  & \cmark  & \xmark \footnotemark\\\cmidrule(r){2-7}
		recept importálás - URL          & \xmark & \xmark & \xmark & \cmark  & \cmark  & \cmark        \\ \cmidrule(r){2-7}
		receptekhez vannak lépések       & \xmark & \cmark & \cmark & \xmark  & \cmark  & \cmark        \\ \cmidrule(r){2-7}
		manuális recept hozzáadás        & \cmark & \xmark & \xmark & \cmark  & \cmark  & \cmark        \\ \cmidrule(r){2-7}
		bevásárlólista                   & \cmark & \xmark & \cmark & \cmark  & \cmark  & \cmark        \\ \cmidrule(r){2-7}
		bevásárlólista ajánló            & \cmark & \xmark & \xmark & \xmark  & \xmark  & \cmark        \\ \cmidrule(r){2-7}
		katgóriák használata receptekhez & \xmark & \cmark & \cmark & \xmark  & \cmark  & \cmark        \\ \cmidrule(r){2-7}
		étkzés tervező                   & \cmark & \xmark & \cmark & \xmark  & \xmark  & \xmark        \\ \cmidrule(r){2-7}
		bejelentkezés google fiókkal     & \xmark & \cmark & \cmark & \cmark  & \xmark  & \cmark        \\ \cmidrule(r){2-7}
		reszponzív weblap                & \cmark & \xmark & \xmark & \xmark  & \xmark  & \cmark        \\ \bottomrule
	\end{tabular}

	\caption{Összefoglaló táblázat a piackutatásról}
    \label{fig:table}
\end{figure}

\footnotetext[1]{Technikailag az, de nem könnyű hosztolni.}
\footnotetext[2]{Jelenleg nem fizetős, de amennyiben fellendül az applikáció népszerűsége, akkor Firebase-el könnyen bevezethető.}

\chapter{Funkcionális specifikáció}
A következők összefoglalják a program főbb funkcionalitásait, azokat felhasználási esetekben (UseCase) csoportosítja. Ez alkotja a  program funkcionális követelményét, azaz azokat a képességeket, amiket mindenféleképpen tudnia kell. Ezeket az elemeket a \ref{fig:useCase}-es ábra grafikusan ábrázolja, majd a fejezet további része pontosítja és kifejti őket.
Az ebben a fejezetben használt képek a már kész applikáció-ból származnak, és illusztrálják a megvalósított funkcionalitásokat.

\noindent
%\includegraphics[scale=0.4]{out/diagrams/useCase/use-case.eps}
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{out/diagrams/useCase/use-case.eps}
	\caption{UseCase diagram}
    \label{fig:useCase}
\end{figure}


\section{Bejelentkezés/Regisztráció}
A weblap használatához be kell jelentkezni vagy regisztrálni kell. Ameddig ez nem történik meg, a felhasználó vendég státuszban van (lásd: \ref{fig:useCase}-es ábra “Vendég”). 

A regisztrációra két lehetőség van. Egyrész a regisztrációs oldalon a mezők (pl.: név, születési év, email, stb) kitöltésével tud manuálisan regisztrálni (lásd: \ref{fig:useCase}-es ábra “Regisztráció manuálisan”). Ekkor a rendszer az azonosításra a megadott email címet használja és ezt kell megadni a jelszavával együtt a belépéskor. Másrészt, ha a vendégnek van Google fiókja, akkor egyszerűen egy lépéssel azonnal regisztrálhat annak felhasználásával (lásd: \ref{fig:useCase}-es ábra “Regisztráció Google fiókkal”).

A bejelentkezésnél a regisztrációhoz hasonlóan két lehetőség áll rendelkezésre. Attól függően, hogy a felhasználó mely módszerrel regisztrált, az annak megfelelő módszerrel kell belépnie. Tehát, ha manuálisan regisztrált, akkor meg kell adni a regisztrációkor használt email címet és jelszót (lásd: \ref{fig:useCase}-es ábra “Bejelentkezés manuálisan”). Amennyiben Google fiókot használt a regisztrációhoz, akkor egyszerűen a “Sign In with Google” gombra kattintva tud belépni (lásd: \ref{fig:useCase}-es ábra “Bejelentkezés Google fiókkal”).
 
\begin{figure}[H]%
    \centering
    \subfloat[\centering Bejelentkezés]{{\includegraphics[width=5cm]{pictures/mobile-login.png} }}%
    \qquad
    \subfloat[\centering Regisztráció]{{\includegraphics[width=5cm]{pictures/mobile-register.png} }}%
    \caption{Bejelentkezés és regisztráció képernyőpépek}% 
    \label{fig:loginRegis}% 
\end{figure}


%\noindent
%\includegraphics[scale=0.5]{pictures/mobil_login.png}
%\includegraphics[scale=0.4]{pictures/web_register.png}

\section{Receptek}
A következőkben a receptekhez kapcsolódó főbb funkciókról lesz szó. Ez az ábrán a “Receptek” csoportban található felhasználási eseteket jelenti. Ezen funkcionalitások alkotják az alkalmazás legfontosabb képességeit. A piackutatásban megállapított fontos funkciókat tartalmazza, például a legfontosabbnak megállapított recept importálást.
%\noindent
%\includegraphics[scale=0.5]{pictures/mobil_home.png}
 
\subsection{Receptek hozzáadása} 
A weblap egyik jellegzetes alapfunkciója, hogy a közösség tölti fel az adatbázist receptekkel. Ez azért fontos, mert így nem az adminisztrátoroknak kell folyamatosan dolgozni, hogy minél több recept legyen elérhető a felhasználók számára. 

Egy recept feltöltésre két lehetőség is van. Az egyik az, hogy a felhasználó manuálisan tölti ki a recept paramétereit (lásd: \ref{fig:useCase}-es ábra “Recept hozzáadás manuálisan”). Ez azokban az esetekben fontos a felhasználó számára, amikor a recept nem az internetről származik, hanem például nyomtatott receptkönyvből vagy családi hagyományból. 

\begin{figure}[H]%
    \centering
    \includegraphics[width=5cm]{pictures/mobile_importDataCheck.png}
	\caption{Egy recept a manuális recept feltöltés közben}%
    \label{fig:importcheck}% 
\end{figure}

A másik opció az, hogy egy másik recepteket tartalmazó weboldal URL címét kimásolja a böngészőből és beilleszti a linket a RecipeHoarder importáló felületére (lásd: \ref{fig:useCase}-es ábra “Recept hozzáadás URL-ből”). Itt, amennyiben a forrás weblap támogatott, a program betölti a recept adatait. Ezután a felhasználónak lehetősége van módosítani a receptet, majd azt kinentve hozzá adni a globális recept lisához.

Mindkét opció során a felhasználónak meg kell adnia, hogy a recept mely előre meghatározott csoportba tartozik (Pl.: Reggeli, Csípős, stb.). Majd a kimentés után a rendszer mind a két módszernél megpróbál kalória mennyiséget számolni a recepthez.

\begin{figure}[H]%
    \centering
    \includegraphics[width=11.5cm]{pictures/web_import.png}
	\caption{A desktopos verzióban a receptfelöltő oldal}%
    \label{fig:importPage}% 
\end{figure}


\subsection{Receptgyűjtemény kezelés}
Ahhoz, hogy a weblap könnyen használható legyen, szükségünk van arra, hogy a felhasználó ki tudjon menteni recepteket egy saját gyűjteménybe. Ez nagyban megkönnyíti a recept későbbi megtalálását. Erre két különböző gyűjtemény áll a felhasználó rendelkezésére. Egyik a saját “receptkönyv”, amibe akárhány receptet kimethet, illetve a kedvencnek ítélt receptek gyűjteménye. A felhasználó bármely megtekintett vagy frissen beimportált receptet ki tud menteni a recept könyvébe (lásd: \ref{fig:useCase}-es ábra “Gyűjteményhez adás”), majd innen, amennyiben tetszett neki, hozzá tudja adni a kedvencekhez. Ez azt jelenti, hogy a kedvencekhez való hozzáadáshoz először ki kell menteni  a saját receptkönyvbe.

Természetesen a felhasználó bármikor meg tudja tekinteni az összes receptet, amit a saját receptkönyvbe vagy kedvencek közé mentett ki (lásd: \ref{fig:useCase}-es ábra “Gyűjtemény megtekintése”). Majd amennyiben egy receptet már nem szeretne az adott listában látni, akkor képes a receptet kivenni a kedvencek/saját receptkönyvből, de ezzel nem törlődik a globális receptlistából, így a többi felhasználó számára elérhető marad (lásd: \ref{fig:useCase}-es ábra “Gyűjteményből törlés”). 

\begin{figure}[H]%
    \centering
    \includegraphics[width=11.5cm]{pictures/web_recipeCollection.png}
	\caption{A desktopos verzióban a felhasználónak a "Receptes kézikönyv"-re képernyőkép}%
    \label{fig:collection}% 
\end{figure}


\subsection{Recept megtekintés}
Mivel ez egy recept gyűjtő webes alkalmazás, ezért egyértelműen lehetőséget kell adni arra, hogy a receptek leírását meg lehessen tekinteni. Itt már megtalálható az összes eltárolt adat a receptről, mint például a elkészítési idő (ha van), kalória (ha van), hozzávalók vagy elkészítési lépések (lásd: \ref{fig:useCase}-es ábra “Recept megtekintés”).

\begin{figure}[H]%
    \centering
    \includegraphics[width=5cm]{pictures/mobil_recipe-top.png}
	\caption{Egy recept képernyőképe}%
    \label{fig:recipe}% 
\end{figure}

\subsection{Receptre szűrés}
A weblapon van lehetőség keresni a receptek között, ezen belül is két mód van erre. Egy általános névre való keresés, valamint kategória szerint is lehet szűrni. Mivel egy recept létrehozásakor kötelező megadni legalább egy kategóriát, így egyszerűen kereshetők ez alapján.

Ez \az{\ref{fig:useCase}-es ábra} “Receptek” csoport alatt, a “Receptre szűrés”-nek felel meg a két lehetséges verziójával, “név szerinti” és “kategória szerinti” szűrés. 

\begin{figure}[H]%
    \centering
    \subfloat[\centering Kereső opciók]{{\includegraphics[width=5cm]{pictures/mobile-home.png} }}%
    \qquad
    \subfloat[\centering Keresés eredmény]{{\includegraphics[width=5cm]{pictures/mobile-search.png} }}%
    \caption{A kezdőoldalon található kategória szerinti szűrés}% 
    \label{fig:catSearch}% 
\end{figure}


\subsection{Hibás recept jelentése}
Korábban volt szó arról, hogy az oldal adatbázisa a közösség által feltöltött receptek alapján nő. Ezért fennáll a lehetősége, hogy akár az importálás során különböző hibák keletkezzenek, amit a felhasználó nem vesz észre vagy nincs kedve kijavítani. Akár az is lehetséges, hogy támadás érje a weblapot, és keletkezzenek olyan receptek, amelyek hibásak. Ennek javítása érdekében minden recepthez tartozik egy hiba bejelentő rész, ahol előre megszabott lehetséges hibák listájából választva jelezhet a weblap karbantartóinak, hogy ha valami nem jó a recepten. Ezen lehetséges hibák közé tartozik például, ha hiányos az alapanyagok listája vagy trágár szavakat tartalmaz.

Ez \az{\ref{fig:useCase}-es ábra} “Receptek” rész alatt, a “Recept megtekintés”-hez tartozik “Hibás recept jelentés” néven.

\begin{figure}[H]%
    \centering
    \includegraphics[width=5cm]{pictures/mobile-report.png}
	\caption{Egy recept hibabejelentés képernyőkép}%
    \label{fig:report}% 
\end{figure}


\section{Bevásárló lista}
Minden felhasználónak van saját bevásárlólistája, amibe össze tudja gyűjteni a számára szükséges alapanayagokat. Ez a lista szintén személyre szabott és csak a felhasználó látja, vagy módosíthatja.

\subsection{Bevásárló listához adás}
A listához adásra két lehetőség van. A szokásos bevásárlólista módszert követve manuálisan is ki lehet tölteni az adatokat, majd a listához adni. A másik módszer a recepteken belül, a felsorolt alapanyagokat is egyesével hozzá lehet adni, illetve a recepteknél lehetőség vagy az összes alapanyagot azonnal hozzáadni a listához. 

Ez \az{\ref{fig:useCase}-es ábra} a “Bevásárlólista” rész alatt, a “Bevásárló listához adás” résznek felel meg.

\begin{figure}[H]%
    \centering
    \includegraphics[width=11.5cm]{pictures/web_shoppinglist-add.png}
	\caption{A bevásárló listához adás mezői}%
    \label{fig:shoppinglistAdd}% 
\end{figure}


\subsection{Bevásárló lista megtekintés}
A bevásárlólista megjelenítésénél a korábban hozzáadott alapanyagok vannak felsorolva. A bevásárlólista az alapanyagokat a hozzáadásuk dátuma szerint jeleníti meg. Igy könnyen követhető, mikor egy új tétel lett a listához adva.  Amennyiben az alapanyagnak nincs mértékegysége vagy mennyisége, akkor azok az adatok nem lesznek megjelenítve, hogy elkerüljük, hogy például “0 pasta“ legyen megjelenítve.

Ez \az{\ref{fig:useCase}-es ábra} a “Bevásárlólista” rész alatt lévő “Bevásárló lista megtekintése” résznek felel meg.

\begin{figure}[H]%
    \centering
    \includegraphics[width=11.5cm]{pictures/web-shoppinglist.png}
	\caption{A bevásárlólistáról képernyőkép}%
    \label{fig:shoppinglist}% 
\end{figure}


\subsection{Bevásárló listából törlés}
Ha a felhasználónak már nem kell egy adott alapanyag a listából, legyen ez azért, mert már megvette vagy csak nem aktuális már, akkor könnyen egy kattintással el lehet tüntetni a listából. Másik verzió a lista ürítésére a lista alatt lévő gomb megnyomásával az egész lista törlése. Így gyorsan és egyszerűen lehet újrakezdeni a lista használatát anélkül, hogy az összes elemet egyesével kellett volna törölni.

Ez \az{\ref{fig:useCase}-es ábra} a “Bevásárlólista” rész alatt lévő “Bevásárló listából törlés” résznek felel meg. 

%\noindent
%\includegraphics[scale=0.5]{pictures/mobil_menu.png}
%\includegraphics[scale=0.5]{pictures/mobil_recipe-top.png} \\
%\includegraphics[scale=0.4]{pictures/web_recipeCollection.png}

%\noindent
%\includegraphics[scale=0.4]{pictures/web_import.png}
%\includegraphics[scale=0.5]{pictures/mobile_importDataCheck.png}

%\noindent
%\includegraphics[scale=0.4]{pictures/web_shoppinglist.png}

%\noindent
%\includegraphics[scale=0.5]{pictures/mobile_suggestion.png}

\chapter{Felhasznált technológiák}
Itt fogom részletezni a kiemeltebb felhasznált technológiákról alapvető információkat, valamint szerepüket ebben a projektben.

\section{Angular}
Az Angular egy \Gls{TypeScript} alapú \Gls{Framework}, amit  eredetileg a Google fejlesztett ki, de most már nyílt forráskódú. Az Angular teljes újraírása a régi \Gls{AngularJS}-nek. Egyik legnagyobb előnye, hogy komponens alapú keretrendszer, ezért ennek segítségével újra felhasználható kódot lehet írni. Támogatja a \Gls{SinglePageApp} készítését. Ezeken a weblapokon a weblap újratöltése nélkül tud a felhasználó navigálni, ezzel is gyorsabbá téve azt.

A felhasználói felület tervezése során is igyekeztem komponenseket kialakítani mind telefonos, mind desktopos kinézetben. A komponensekkel való munka megkönnyíti egy projekt fejlesztését, mivel akár saját fejlesztésből, akár külső könyvtárból szerzett elemekből lehet egyszerűen felépíteni a weblapokat. Ezeknek az elemeknek másik nagy előnye, hogy elég csak az eredetit módosítani ahhoz, hogy mindenhol megváltozzon, ezzel is egységesítve az oldal szerkezetét, valamint segítve a fejlesztők dolgát.


\section{Angular Material} 
Az Angular Material egy, a Google által fejlesztett komponens csomag. 
Ez segít a fejlesztőknek már kész és modern dizájnos komponenseket egyszerűen felhasználni a projektekben. 
Ez elsősorban egy UI komponens dizájn könyvtár, ami importálás után egyszerűen használható. 
A weboldalán pedig példákkal és részletes dokumentációval fel vannak sorolva a létező komponensek és ezek különböző változatai.

Az én projektem is nagy részben ennek a könyvtárnak a komponenseit használja fel. 
Csak pár helyen kellett kiegészíteni a már létező verziót, hogy illeszkedjenek az eredeti tervekhez. 
Ezen felül a projekt témája is az Angular Material alapján lett felépítve, hogy a komponenseknek könnyen meglehessen adni az alap színeket és tipográfia szabályokat.


\section{Firebase}
Eredetileg független cég által fejlesztett, de most már a Google által fejlesztett webes és mobilos alkalmazások készítéséhez létrehozott platform. 
Manapság nagyon népszerű az egyszerűsített adatbázis felépítése, valamint a könnyű és könnyen értelmezhető kezelő felülete miatt, arról nem is beszélve, hogy rengeteg dokumentáció létezik a fejlesztők számára.

Ebben a projektben elég sok helyen használom a Firebase funkcióit. 
Az egész weblap a Firebase Hosting platformon működik, ami egy statikus weblap hosztolási felület. 
Ez a GitHub-bal össze van kötve, ha a Main Branch-re feltöltés történik, akkor a Firebase-re automatikusan feltöltődik az új production verzió.

A FireStore Database-t használom a weblap adatainak tárolásához. 
Itt vannak eltárolva  receptek, felhasználók, a felhasználókhoz különböző kollekciók és bevásárló listájuk illetve \gls{Metaadatok}. 
A Cloud FireStore-on belül lehet beállítani az adatbázis Rule-okat. 
Ezt azt jelenti, hogy be lehet állítani, hogy különböző kollekciókat kik érhetnek el, milyen tevékenységek vannak engedélyezve nekik, valamint, hogy milyen jogokkal milyen adatbázis műveleteket lehet csinálni. 

A FireBase Storage-ban tárolódnak a receptekből kimentett képek, amik az importálás során kerülnek az adatbázisba.

A legnagyobb biztonság érdekében a Firebase Auth-ot használom a weblap bejelentkezés és regisztrációs műveleteihez. 
Így lehetséges email és jelszó párossal regisztrálni majd bejelentkezni, viszont, akinek van Gmail fiókja, annak lehetősége van egy lépésben azonnal regisztrálni és belépni annak segítségével.

A recept importálás és a bevásárlólista egy része a Firebase Cloud Function keresztül a szerver oldalon fut. 
Ez nem csak olcsóbb, mivel szerver oldali adatbázis lekérdezések ingyenesek a kliens oldalival szemben, hanem az importálás során felmerült problémát is megoldotta. 
Ez a  probléma az, hogy egy honlap nem kérdezhet le adatot egy másikról kliens oldalon keresztül, mivel a cél weblapok CORS beállítása ezt nem engedi. 
Azon kívül, mikor a bevásárló listába új alapanyag kerül, akkor egy trigger lefut a szerver oldalon, aminek segítségével állítjuk elő az ajánlóhoz a metaadatokat.


\section{PWA}
A PWA azaz Progressive Web Application egy koncepció, amit követve lehetséges megbízható, stabil és telepíthető webes applikációkat fejleszteni. 
Az alapszabályait követve a weblap akár platformspecifikus alkalmazássá is alakítható. A PWA lehetővé teszi az alkalmazások használatát bárhol, bármikor, bármilyen eszközön. 

A projekt esetében az Angular-t ki kell kiegészíteni JavaScript kóddal. 
Ha az eszköznek nincs internet elérése, akkor a script segítségével a weblapnak lokálisan elmentett változatát használja a böngésző. 
Ezzel elérhető, hogy valamilyen szinten használható legyen a weblap offline környezetben is. Szerencsére mind az Angular, mind an Firebase úgy lett kifejlesztve, hogy csak egy-egy helyen kell megadni neki, hogy az Angular Service Worker-t használja, ezért nekem nem kellett saját kódot írni ahhoz, hogy internet nélkül is használható legyen a weblap. Ez persze limitált arra, ami cachelve lett, például a keresés csak a már egyszer letöltött receptekre fog működni, de a bevásárló listához adás során, mikor az eszközön újra lesz internet, az egész szinkronizálódik, hogy ne legyen adatvesztés.

\section{Schema.org}
A schema.org egy kereső cégek által kezdett indítvány aminek része a Google, Yahoo és Bing!. 
A céljuk az, hogy az interneten való keresést megkönnyítsék az által, hogy a weblapok egy a számítógépek által könnyen értelmezhető formátumban is elérhetővé teszik a tartalmukat. 
Az indítvány összefoglalja, hogy milyen tartalmakat tudnak az egyes weblapok leírni és ezeknek milyen konkrét tulajdonságaik lehetnek. 
A weblapokban ezeket az adatokat több féle tényleges formátumban lehet eltárolni úgy, hogy azt a megjelenítés során nem rajzolja ki. Ezek közül a legelterjedtebb a JSON-LD, ami a HTML head részében elhelyezett JSON formátumú adatot jelent.

A projektben a legfontosabb a “Recipe“ séma, ami leírja hogy a receptnek milyen tulajdonságait lehet megtalálni a JSON-LD kódban. 
Sajnos a standardizáció ellenére a különböző weblapok sok adatot eltérő módokon adnak meg, igy ez az adat további feldolgozásra szorul. 
A helyzetet tovább rontja az, hogy nem minden adatot kötelező megadni a sémában, így például elképzelhető, hogy egy receptnek hiányoznak a lépései. 


\section{Figma}
Egy  vektorgrafikus szerkesztő, ahol felhasználói felület prototípusokat lehet tervezni. A program legfőképp webalapú, de letölthető desktopos verziója is. 
A program képes a tervezett lapok élő tükrözésére akár saját telefonon az applikáción keresztül, vagy csak az emuláló felületen keresztül. 
A Figma egy modern dizájn tervező app, amiben egyszerűen fel lehet használni a material design stílust és alap komponenseket, ezzel is segítve az Angular-ban is használt komponens alapú gondolkodást. Másik nagy előnye, hogy interaktívvá lehet tenni a tervezés során a gombokat, komponenseket, így akár a teljes felhasználói élmény kipróbálható. Ezen túl meg lehet nézni a kész dizájnoknak  a pontos CSS stílus kódját is, ezzel is segítve a konkrét kódolás folyamatát.

Ez a program sokat segített a tervezésben, mivel a kész material design komponenseket tudtam próbálgatni anélkül, hogy először mélyebben kellet volna tanulmányoznom az Angular felépítését. 
Az egységes dizájn és téma tervezésében pedig segített konzisztensnek maradnom. Ez igaz mint a színekre, mind a tipográfiára.


\chapter{A rendszer magas szintű áttekintése}
\label{systemExplanation}
Mint minden más webes alkalmazás, ez a projekt is egyértelműen felbontható két fő egységre a szerver és a kliens oldal mentén. 
A kliens oldal azt a kódot és egyéb fájlokat jeleni, amiket az interneten keresztűl a felhasználó böngészője tölt le és futtat. 
Míg a szerver oldali kód az egy központi helyen fut és a hosszabb időt igénybe vevő számításokat, illetve az adatbázis elérését végzi.

\noindent
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{out/diagrams/deployment/deployment.eps}
	\caption{Diagram a kilens és szerver oldali összeköttetésről}
    \label{fig:deployment}
\end{figure}

\section{Szerver oldal}
A projekt esetében a szerveroldali funkcionalitások a Firebase segítségével lettek megvalósítva (lásd: \ref{fig:deployment}. ábra Firebase eleme). 
Ez nagyban megkönnyítette a munkát, mivel a szerver tényleges működtetését a Firebase végzi. 
Az adatbázis szerepét a Firebase Firestore tölti be (lásd: \ref{fig:deployment}.  ábra Firestore eleme), ami egy NoSQL alapú adatbázis (lásd: \ref{dataSchemes}. fejezetben részletesebben).  Ez egy biztonságos, kliens oldalról is használható API-val rendelkezik, aminek segítségével az adatbázis műveletek elvégzéséhez nincs szükség saját szerver oldali kód írására. A weblap statikus fájljainak kiszolgálására a FireBase Hosting van használva, aminek segítségével nincs szükség saját \Gls{Apache} vagy \Gls{NGINX} szerver üzemeltetésére. Ahol szükséges volt a szerver oldalon saját kódot futtatni, ott a FireStore által nyújtott Cloud Functions megoldást használtam.

\subsection{Firebase functions}
A Firebase functions egy olyan felhő alapú megoldás, ahol a fejlesztőnek csak a ténylegesen futtatni kívánt kódot kell megadnia. 
A virtuális gép, az azon futó operációs rendszer és a program elindítása mind a platform által van kezelve. Ez nagyban megkönnyíti a fejlesztést, mivel nem kell plusz időt fordítani a szerver karbantartására. A Firebase JavaScript/ \Gls{TypeScript} -ben írt kódot tud futtatni. Mivel a kliens oldal is \Gls{TypeScript}-ben készűlt, ezért bizonyos funkciókat, illetve adatstruktúrákat a két komponens között meg lehet osztani. 

A fejlesztő álltal megírt programokat többféle események is elindíthatják. Leggyakoribb példák erre a bejövő HTTP kérések vagy az adatbázisban történt változások. Ezek közül a projekt mind a kettőt használja. 

A szerver oldalon két fő funkcionalitást kellett megvalósítani. Első és legfontosabb a receptek importálásáért felelős Cloud Function. Ez a kliens által küldött speciális HTTP üzenetre indul el és végzi el a receptek letöltését és értelmezését. A második funkcionalitás a bevásárló lista ajánlóhoz metaadatok előállítását végzi, amit minden bevásárlólistához adáskor elvégez.

\subsection{Google Auth}
A Google felhasználói fiókkal való belépéshez természetesen a Google által üzemeltetett azonosító szerverrel kell kommunikálni a mind a kliensnek, mind a szervernek. A kliens a kommunikáció során elvégzi a felhasználói adatok megszerzését, majd ezeket a szerver is hitelesíti. Mindezt a Firebase Auth szolgáltatása autómaikusan elintézi. Az Auth szolgáltatás előnye, hogy sok más platformot is támogat például Facebook és Twitter. 

\section{Kliens oldal}
A kliens a projekt esetében a felhasználó web böngészőjében futó kódokat jelenti. ez két fő egységre választható szét. Az egyik a ténylegesen megjelenő weblap kódja, amely tartalmazza a megjelenítéshez szükséges HTML, CSS és JavaScript fájlokat. A másik komponens a weblap offline elérését biztosító Service Worker. Ami a webböngészőben, mint háttérfolyamat fut.

\subsection{Weboldal}
A weboldalt az Angular fordítási folyamat eredményeképp létrejövő fájlok alkotják. Ezek a fájlok tartalmazzák a lefordított \Gls{TypeScript} kódot, ami egy JavaScript fájlba lett generálva, illetve tartalmazza még a hasonló módon összesített stílusokat egy CSS fájlban. Ezeket a fájlokat a kliens a Firebase Hosting szerveréről tölti le, ami egy statikus fájlkiszolgáló rendszer. Azért lett ez választva, mivel a Google szervereit használja, így magas szintű megbízhatóságot biztosít. Továbbá automatikusan jól skálázódik, ha a weblap forgalma hirtelen megnövekszik. Ezen tulajdonságai miatt, ez egy olyan platformot biztosít, ami bármekkora felhasználói bázis mellett jól használható.

A fordítás kimeneti fájljai autómatikusan feltöltésre kerülnek, amikor a GitHubra-ra egy új verzió kerül fel. Ezzel biztosított, hogy a feltöltés közben emberi hiba nem történhet.


\subsection{Service Worker}
A Service Worker egy olyan relatív új funkciója a webböngészőknek, ami régi böngészőkön például Internet Explorer egyáltalán nem támogatott. A funkció lényege az, hogy megadhatók egy olyan JavaScript kód, ami tudja kezelni a weblap által indított HTTP lekérdezéseket. Ennek segítségével amennyiben nincsen nincsen internet kapcsolat, a Service Worker képes mégis visszaadni adatokat. Így, amennyiben a lekérdezések eredménye a LocalStorage-ba ki lett mentve, akkor azokat internet hiányában is vissza lehet kapni.

Ezt a funkcionalitást az Angular által szolgáltatott ServiceWorker megvalósítja, így ehhez a fejlesztőnek plusz munkát nem kell végeznie. Amennyiben az applikáció komplexebb adatok tárolását igényli, szükség lehet ennek az újraírására. Ezen projekt számára a beépített Service Worker megfelel, így nincs szükség saját kód írására. Mivel a Service Worker csak a második újratöltésre szolgáltat új kóddal, ezért egy figyelmeztető ablak lett implementálva, ami jelzi a felhasználónak, ha új verzió érhető el és lehetőséget ad az új verzió betöltésére.



\chapter{Architektúra}
Ebben a fejezetben \az{\ref{systemExplanation}-es fejezetben} leírt komponensek kerülnek részletes leírásra.

\section{Kliens}
A kliens oldal felépítését nagyban meghatározza az, hogy Angular keretrendszer van használva a projektben, ami sok programozási mintát megkövetel. Ezek segítenek az újrafelhasználható, illetve megbízható kódot írni.

\noindent
\begin{figure}[H]
	\centering
	\includegraphics[width=.8\textwidth]{out/diagrams/clientRecipeImport/clientRecipeImport.eps}
	\caption{A recept importálás a kliens szemszögéből}
    \label{fig:clientRecipeImport}
\end{figure}

\subsection{Angular által nyújtott szolgáltatások}
Az Angular által előírt minták közül a legfontosabb a komponens minta. Mivel így az általunk készített grafikus komponenseket az oldalon akárhány helyen fel tudjuk használni. Ezek a komponensek a fejlesztés alatt úgy viselkednek, mintha tényleges HTML elemek lennének, majd futtatáskor az Angular rendszere helyettesíti be az általunk megadott HTML szegmenseket.

Továbbá a keretrendszer lehetőséget biztosít service-k írására és használatára. Ezek olyan speciális osztályok, amelyeket a komponensekből el tudunk érni és komponenshez szorosan nem köthető funkcionalitásokat lehet bennük megvalósítani. Az elérésükhöz az Angular dependency injection-t biztosít. Ennek a lényege az, hogy a felhasználni kívánt service-t mint bemeneti paraméter van feltéve az osztály konstruktorában. Így, amikor az Angular-nak létre kell hoznia az osztályt, automatikusan átadja neki a service egy példányát.  Ezt a megoldást sok más környezetben például JAVA-ban is szokás használni.

\subsection{Recept letöltés}

\subsection{Saját kollekcióba mentés}

\subsection{Bevásárló listához adás}

\section{Szerver}

\subsection{Recept importálás}

\subsection{Bevásárlólista metaadat kezelés}

\chapter{Adatmodellek}
\label{dataSchemes}
Az adatbázis felépítése különbözik a megszokott táblás módszertől, mivel a Firebase a NoSQL módszerrel tárolja az adatokat, amivel gyorsabb a keresés az adatok között. A szerkezete nagyon egyszerű, mivel csak egyszerű kollekciónkból és dokumentumokból áll, felépítése hasonlít a JSON fájltípusokra. Minden adat egy-egy dokumentumban tárolódik és ezek a dokumentumok vannak elrendezve kollekcióban. A szokványos SQL adatbázisoktól eltérően a FireStore-nak nincs fix sémája. Ez azt jelenti, hogy egy kollekción belül a dokumentumoknak a felépítése nem rögzített. Így előfordulhat az, hogy egy dokumentumnak a többihez képes több vagy kevesebb adata van. Emiatt a dokumentumok frissítésére külön energiát és figyelmet kell fordítani. Ezt a legtöbb esetben Cloud Functions futtatásával szokás megoldani.

A FireStore-ban a dokumentumok olyan felépítésű adattárolók, amelyekben egy tetszőleges szöveges kulcshoz tudunk valamilyen típusú adatot rendelni. Ezek az adatok lehetnek: 

\begin{itemize}
	\item \textbf{Szöveg} (string), ami UTF-8 kódolású és maximum 1MiB méretű lehet
	\item \textbf{Szám} (number),  tetszőleges pontosságú számérték
	\item \textbf{Igaz/Hamis} (boolean), igaz vagy hamis
	\item \textbf{Tetszőleges adatstruktúra} (map), ez egy a JSON formátumhoz nagyban hasonlító kötetlen adatmező
	\item \textbf{Üres} (null)
	\item \textbf{Időpont} (timestamp), ez egy dátumot és másodpercre pontos időpontot jelez

	\item \textbf{Földrajzi koordináta} (geopoint), hosszúsági és szélességi fokot egy mezőben tároló típus

	\item \textbf{Referencia} (reference), másik dokumentumra mutató elérési út
	\item \textbf{Tömb} (array), egy különleges tároló, ami az eddig felsorolt összes típusból képes sokat eltárolni

\end{itemize}
 

\section{A receptek eltárolása}
Az adatbázisban a legfontosabb adatok a receptek, mivel ezekre épül az egész weblap témája. A receptek a feltöltés során automatikus azonosító ID értéket kapnak, ami a weblapon az URL címben az azonosításért is is felelős. A recepteket egy kollekcióban tároljuk és ezen belül a dokumentumok az adott recept adatait tartalmazzák, ezek közé tartozik például: kalória, teljes főzési idő (percben mérve), recept neve, eredeti URL, stb. Ezek az alap adatok csak simán kulcs érték párok.

Alapanyagokon belül eltároljuk az alapanyag nevét, mennyiségét és mértékegységét. A recept elkészítésének lépéseihez tároljuk a sorrendbeli számát és a lépés leírását. Jelenleg még kulcs-tömb értékben vannak tárolva az alapanyagok és lépések, viszont a jövőben megváltoztathatjuk alkollekcióvá a gyorsabb betöltési idő eléréséért.

\noindent
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{out/diagrams/jsonRecipes/jsonRecipes.eps}
	\caption{Minta a receptek adatbázis felépítéséről}
    \label{fig:jsonRecipes}
\end{figure}

\section{Felhasználók eltárolása}
Az adatbázisban a felhasználókat egy kollekcióban tároljuk. A regisztráció során létrejön egy új dokumentum az adatbázisban. Itt tároljuk el az egyéb adatokat, amit a felhasználó az alap e-mail és jelszón kívül megad. Az egyéb adatok segíthetnek a jövőben személyre szabott recept ajánlót készíteni. 

Minden felhasználóhoz továbbá eltároljuk a Firebase Auth által adott “UID” azonosítót, ami garantáltan egyedi. Itt a korábban említett kulcs-tömb típushoz képest már alkollekciók lettek bevezetve. Ezekben az alkollekciókban tároljuk el a felhasználó által elmentett recepteket, illetve hasonló módon tároljuk el a bevásárló lista adatait is.

Az alkollekció azért fontos ebben az esetben, mert ha le akarjuk kérdezni a felhasználó kedvenc receptjeit, akkor nem kell mindig az egész felhasználói adatot lekérdezni, hanem lekérdezhető ugyanúgy, mint egy egyedülálló kollekció. Ezzel gyorsabb lesz a weblap, valamint spórolunk a fölösleges adatok kezelésével is. A felhasználó által a könyvtárába elmentett receptek, a felhasználó dokumentuma alatt lévő “base” alkollekcióban kerülnek tárolásra. Ezek a recept ID-jét és a kimentési időpontot tartalmazó dokumentumokkal vannak eltárolva. Ugyanez igaz a kedvencek listára, ami a  “favourites” alkollekcióban van tárolva. Amint a felhasználó kimentett egy receptet a saját listájába, akkor van lehetősége ezt tovább elmenteni a kedvencek közé. Ez ugyanúgy működik, mint az egyszerű listába mentés. Amennyiben viszont a saját listájából törli a receptet, akkor a kedvencek közül is eltűnik. 

A bevásárló listába az alapanyagokról a mentés dátumát és a pontos adatokat is elmentjük. A létrehozás dátuma a sorrendbe rendezés és a metaadat számítás miatt fontos. Ha a felhasználó úgy dönt, hogy a lista elem már nem aktuális, akkor az törölhető a listából. Továbbá a bevásárló listáról el vannak tárolva meta adatok, amiket egy-egy termék kettő listához adása között eltelt időből számolunk ki. Az ajánló jelenleg csak az alapanyag nevét ajánlja fel, viszont a mértékegység és mennyiség is el van tárolva, ezt a jövőben pontosabb számításokra lehet felhasználni. Ezen kívül, mikor az adat létrejön, a “score” értéke 2. Ez egy érték, ami segít az ajánlás sikerességét követni, max értéke 5, minimum értéke 0. Végül a “nextDate” egy számolt TimeStamp érték, ami a eredeti hozzáadás dátumából és az újonnan hozzáadott alapanyag dátumából számolunk ki.

\noindent
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{out/diagrams/jsonUsers/jsonUsers.eps}
	\caption{Egy minta felhaszáló adatairól}
    \label{fig:jsonUsers}
\end{figure}

\section{Recept hibajelentések tárolása} 
Mivel a weblap úgy lett tervezve, hogy a közösség építi, és mindenki ugyanazokat a recepteket látja, ezért lennie kell egy lehetőségnek, ahol a felhasználók hibát tudnak jelezni és ezeket a hibákat az adatbázisban el kell tudni tárolni. Tehát minden recept végén van lehetőség visszajelzést  küldeni, ha hibás receptet találnak. A bejelenthető hiba típusai fixek, így könnyebben lehet a jövőben megkeresni, hogy mi lehet a hiba az adott recepttel. 

Ezeket a bejelentett hibákat egy kollekcióban tároljuk, ahol minden dokumentum egy-egy bejelentett hibát tárol. A “creationDate” a bejelentés idejét jelzi. A “problem” pedig az opciókból választott problémát legjobban leíró lehetőség, amit a felhasználó választ. Végül feljegyezzük, hogy melyik receptnél volt ez és hogy ki küldte. A “userId” megegyezik a korábban említett “uid” értékkel a “users” kollekcióból, mivel ez az érték, ami a bejelentkezés során az auth adott a felhasználónak.

\noindent
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{out/diagrams/jsonReports/jsonReports.eps}
	\caption{Egy minta a hiba bejelentésre}
    \label{fig:jsonReports}
\end{figure}

%\includegraphics[width=\textwidth]{out/diagrams/jsonReports/jsonReports.png}
%\includegraphics[width=\textwidth]{out/diagrams/jsonReports/jsonReports.eps}


%\chapter{Fontosabb kód részek és ismertetései}
%\section{asd} -> A rendszer magas szintű áttekintése


\chapter{Tesztelés}
A fontosabb funkciók, amik meghatározzák az alap témáját a weblapnak tesztelve lettek. A szerver oldali funkciók mind, az alap működések közé tartoznak,ezért a cloud function moduloknak be lett állítva automatikus tesztelés. Ennek segítségével, ha valami nagyobb változtatást csináltunk,mint például egy rendszer szintű frissítés a FireBase csomagnak, akkor egyszerűen le lehet tesztelni, hogy még minden jól működik-e. Ezt egyszerű unit tesztekkel oldottam meg. A teszteket az npm-ről szedett Jasmine csomaggal készítettem.

\section{Recept importálás URL-en keresztül}
Mivel ez a folyamat modulárisan lett felépítve, ezért minden egyes lépését egyszerű tesztelni. A modulok egyesével és a végeredmény is külön tesztelve van.

\subsection{FetchUrlData}

\subsection{JsonLdExtractor}

\subsection{SeparateIngredients}
Az alapanyag szétválasztás az egyik legkényesebb része a importálás folyamatnak, mivel ebben a részben egy string adatot kell megvizsgálni és különböző adattagokra osztani. Ehhez különböző regex formulák lettek kifejlesztve, hogy a különböző eseteket minél jobban és pontosabban tudjuk feldolgozni. Ehhez, egy egyszerű alap és egy komplexebb teszt készűlt.

Az első célja, hogy le ellenőrizze, hogy a tört szám karakter és egyéb tört szám változatok helyesen vannak átkonvertálva float értékre. A második teszt pedig egy tömböt kap értéknek, amiben rengeteg különböző eset van felsorolva olyan példákkal, amit élő importálás során kaphatunk és szélsőséges probléma lehet. Ezek közé tartozik a három alapeset, ahol vagy szépen visszaadja a mennyiséget, mértékegységet és az alapanyag megnevezését, vagy ha nem talál mértékegységet, de van szám, akkor berendezi, hogy mennyi datab alapanyagot talált, vgay végűl, ha nincs szám se, akkor csak simán visszaadja alapértelmezett módon. Ezen kívül le kell ellenőrizni azokat az eseteket, amik komplexé tették a regex teszteket például, a korábban említett tört karakter helyes észlelése és formázása.

\subsection{ImageDownloader}

\subsection{CalorieCalculator}

\section{GetData}

\chapter{Továbbfejlesztési lehetőségek}
\section{Személyre szabott ajánló}
Mivel a regisztrációnál sok egyéb adat van még eltárolva a felhasználóról, ezért ezeket fel lehet használni, hogy személyre szabott receptajánlója legyen mindenkinek a kezdőoldalon. Ez azt jelenti, hogy felmérést lehet indítani arról, hogy az adatbázisban lévő receptek mely felhasználó csoporthoz vannak leggyakrabban elmentve. Ezeket az adatokat a jövőben fel lehet használni a  receptek listázásához a ajánlóban. 

Amíg a receptet nem mentette ki eléggé sok ember, addig nehéz lehet megállapítani, hogy mely felhasználói csoportoknak tetszhet. Így ilyenkor a feltöltő csoportjához sorolhatjuk, ezzel is segítve a recept korai javaslását.


\section{Recept ellenőrző admin felület}
Jelenleg már létezik minden recept alatt egy bejelentő mező, ahol hibákat tudnak a felhasználók küldeni a receptek állapotáról. Jelenleg ez még csak el van tárolva az adatbázisban, viszont a jövőben, a könnyű kezelés érdekében ezekhez lehetne csinálni egy adminisztrációs felületet. Ezen az oldalon ki lennének listázva a hibás receptek és az admin egy kattintással rá tud nézni a receptre úgy, ahogy a felhasználók is látják.

Itt két lehetősége lenne a hiba megoldására. Ha olyan a recept, hogy nem egyértelmű hogyan lehetne javítani, akkor az törlésre kerül. Ehhez írni kell egy olyan funkciót, ami nemcsak törli az adatbázis receptek kollekciójából, hanem törli,  a felhasználók  recept gyűjteményeiből is. Amennyiben a javítás lehetséges, akkor az admin számára az összes adat módosítható, így könnyen meg tudja tenni a javítást.


\section{Desktop-os és Telefonos kinézet továbbfejlesztése}
Jelenleg a mobilos és desktopos nézetek nem használják ki az adtott platform által nyújtott lehetőségeket tökéletesen. Így például az asztali nézetben sok üres kihasználatlan hely marad, míg bizonyos komponensek a telefonon túl nagyok. Ezeket az alap beviteli komponensek lecserélésével lehetne javítani, illetve az asztali nézetet esetleg újra gondolni az üres helyeknek új felhasználát kitalálni.  

\section{Mértékegység átváltás}
Mivel három féle mértékegységet szokás használni főzésnél, mégpedig az Egyesült Államok által használt rendszert (cup, ounce, inch, stb) vagy az általános SI mértékegységeket (ml, g, dkg, stb.) és konyhai mértékegységeket (tsb, tbsp, stb.), így a recept nézetben hasznos volna, ha az összetevők mértékegységeit automatikusan át tudná váltani a program. Ez azért jutott eszembe, mivel általában az emberek csak az egyiket vagy a másikat ismerik jobban. Tehát be lehetne állítani a profilban, hogy a felhasználó melyiket preferálja, valamint, hogy akarja-e, hogy mindig át legyenek váltva. Ezen kívül lehet még akár minden recept tetején egy gombbal megkérni a weblapot, hogy váltsa át a mértékegységeket.

\section{Főzési folyamat lejátszó}
Ha valaki telefonon néz meg egy receptet, akkor elég zavaró tud lenni mikor egy recept lépés közepén azt írják, hogy “használd fel a fentebb említett alapanyagokat”, amihez föl-le kell mozgatni a képernyőt. Ezzel elvesztve, hogy hol tartottunk a rept lépései között. Ennek a problémának megoldása érdekében lehetne egy “lejátszás” gomb, ami továbbvisz egy olyan lapra, amin a lépések egyesével vannak megjelenítve  a hozzájuk tartozó alapanyagokkal. Amikor egy lépés kész, egy gombbal a következő lépésre lehetne menni. 

Így könnyen követhető lenne a főzés folyamata. Valamint, mivel az alapanyagok külön mértékegységgel és mennyiséggel vannak eltárolva, ezért pontos értékeket lehet megadni a különböző lépésekben ha ugyanazt az alapanyagot több részletben és több lépésben kell felhasználni.


\section{Videók és képek jobb felhasználása}
Vannak olyan receptek, ahol videó is szerepelt a recept adatai között. Viszont ezt a videó lenne  jelenleg nincs eltárolva és a felhasználónál nem jelenik meg. Ehhez a szükség lenne a programban egy videó lejátszóra. A videó eltárolására két lehetőség van. Az egyik esetben a teljes videó a weblap saját felhő alapú tárhelyére lenne kimentve, ez a legmegbízhatóbb de a várhatóan a legdrágább megoldás is. A Második opció az pedig, hogy csak a videóra mutató URL címet tároljuk el hasonlóan a jelenlegi képekhez.

Jelenleg a képeknek is csak az url címe van elmentve de a képeket letöltő Cloud Function már kész van. Ez azért nem fut jelenleg, mert a kliens oldalról a manuálisan megadott receptek képeit bonyolultabb feltölteni. 


\chapter*{Nyilatkozat}
%Egy üres sort adunk a tartalomjegyzékhez:
\addtocontents{toc}{\ }
\addcontentsline{toc}{section}{Nyilatkozat}
%\hspace{\parindent}

% A nyilatkozat szövege más titkos és nem titkos dolgozatok esetében.
% Csak az egyik tipusú myilatokzatnak kell a dolgozatban szerepelni
% A ponok helyére az adatok értelemszerűen behelyettesídendők es
% a szakdolgozat /diplomamunka szo megfeleloen kivalasztando.


%A nyilatkozat szövege TITKOSNAK NEM MINŐSÍTETT dolgozatban a következő:
%A pontokkal jelölt szövegrészek értelemszerűen a szövegszerkesztőben és
%nem kézzel helyettesítendők:

\noindent
Alulírott %\makebox[4cm]{\dotfill}
Vas Laura, gazdaságinformatikus szakos hallgató, kijelentem, hogy a dolgozatomat a Szegedi Tudományegyetem, Informatikai Intézet %\makebox[4cm]{\dotfill} 
Szoftverfejlesztés Tanszékén készítettem, %\makebox[4cm]{\dotfill}
Bsc diploma megszerzése érdekében.

Kijelentem, hogy a dolgozatot más szakon korábban nem védtem meg, saját munkám eredménye, és csak a hivatkozott forrásokat (szakirodalom, eszközök, stb.) használtam fel.

Tudomásul veszem, hogy szakdolgozatomat / diplomamunkámat a Szegedi Tudományegyetem Informatikai Intézet könyvtárában, a helyben olvasható könyvek között helyezik el. 

\vspace*{2cm}

\begin{tabular}{lc}
	Szeged, \today\
	\hspace{2cm} & \makebox[6cm]{\dotfill} \\
	             & aláírás                 \\
\end{tabular}


\vspace*{4cm}



%\chapter*{Köszönetnyilvánítás}
%\addcontentsline{toc}{section}{Köszönetnyilvánítás}

%Ezúton szeretnék köszönetet mondani \textbf{X. Y-nak} ezért és ezért \ldots


%% Az itrodalomjegyzek keszitheto a BibTeX segedprogrammal:
%\bibliography{diploma}
%\bibliographystyle{plain}

%VAGY "kézzel" a következő módon:
 
\begin{thebibliography}{9}
	%10-nél kevesebb hivatkozás esetén 

	%\begin{thebibliography}{99}
	% 10-nél több hivatkozás esetén

	\addcontentsline{toc}{section}{Irodalomjegyzék}

	%Elso szerzok vezetekneve alapjan ábécérendben rendezve.


	%folyóirat cikk: szerzok(k), a folyóirat neve kiemelve,
	%az evfolyam felkoveren, zarojelben az evszam, vegul az oldalszamok es pont.

	%könyv (szerzo(k), a könyv neve kiemelve, utana a kiado, a kiado szekhelye, az evszam es pont.)

	\bibitem{angular}
	\href{https://angular.io/docs}{Angular dokumentáció}, \\
	\url{https://angular.io/docs}

	\bibitem{firebaseDocs}
	\href{https://firebase.google.com/docs/build}{Firebase dokumentáció}, \\
	\url{https://firebase.google.com/docs/build}
	
	\bibitem{angualMaterialDocs}
	\href{https://material.angular.io/guide/getting-started}{Angular Material dokumentáció}, \\
	\url{https://material.angular.io/guide/getting-started}  

	\bibitem{angularFire}
	\href{https://github.com/angular/angularfire}
	{Angular Fire dokumentáció (Firebase API)},\\
	\url{https://github.com/angular/angularfire}

	\bibitem{angularServiceWorker}
	\href{https://angular.io/guide/service-worker-intro}{Angular Service Worker dokumentáció}, \\
	\url{https://angular.io/guide/service-worker-intro}

	\bibitem{schema.org}
	\href{https://schema.org/}{Shema.org}, \\
	\url{https://schema.org/}

	\bibitem{js-quantities}
	\href{https://www.npmjs.com/package/js-quantities}{Mértékegység átváltó 1}, \\
	\url{https://www.npmjs.com/package/js-quantities}

	\bibitem{convert-units}
	\href{https://www.npmjs.com/package/convert-units}{Mértékegység átváltó 2}, \\
	\url{https://www.npmjs.com/package/convert-units}

	\bibitem{AngularPWADocs}
	\href{https://angular.io/guide/service-worker-getting-started}{Angular PWA dokumentáció}, \\
	\url{https://angular.io/guide/service-worker-getting-started}

\end{thebibliography}

\chapter{Melléklet}

\printglossary[title=Szótár]
%\addcontentsline{toc}{section}{Szótár}

\end{document}
